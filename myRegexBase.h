#pragma once
#include <map>
#include <regex>
#include <string>
#include <tuple>
#include <vector>

#define MHPP(arg)  // arg is for makeheaderspp.exe, to be ignored by compiler

// Regex wrapper with named captures using C++17 STL regex only.
// Note that code inside a derived class has direct access to members, without requiring any qualifying text input, which allows for concise and readable code.
class myRegexBase {
   public:
    // captured range reference to the original string, supports line-/character count in the input e.g. for error messages
    class range {
       public:
        MHPP("begin myRegexBase::range")  // === autogenerated code. Do not edit ===
       public:
        // construct begin-end range with complete text (e.g. file contents) starting at istart
        range(::std::string::const_iterator istart, ::std::string::const_iterator ibegin, ::std::string::const_iterator iend);
        // e.g. l100c3 for character 3 in line 100 (base 1, e.g. for messages)
        ::std::string getLcAnnotString() const;
        void getEndLineCharBase1(size_t& ixLineBase1, size_t& ixCharBase1) const;
        ::std::string str() const;
        void getBeginLineCharBase1(size_t& ixLineBase1, size_t& ixCharBase1) const;
        // start of string that contains the range (e.g. to report line / character count in error messages)
        ::std::string::const_iterator start() const;
        // start of range in a string beginning at start()
        ::std::string::const_iterator begin() const;
        // end of range in a string beginning at start()
        ::std::string::const_iterator end() const;

       protected:
        void getLineCharBase1(::std::string::const_iterator itDest, size_t& ixLineBase1, size_t& ixCharBase1) const;
        MHPP("end myRegexBase::range")

        ::std::string::const_iterator istart;
        ::std::string::const_iterator ibegin;
        ::std::string::const_iterator iend;
    };

    typedef ::std::pair<::std::string::const_iterator, ::std::string::const_iterator> range_t;
    MHPP("begin myRegexBase")  // === autogenerated code. Do not edit ===
   public:
    static myRegexBase txt(const ::std::string& text);
    static myRegexBase rx(const ::std::string& re, bool isGroup);
    static myRegexBase zeroOrMore_greedy(const myRegexBase& arg);
    static myRegexBase zeroOrMore_lazy(const myRegexBase& arg);
    static myRegexBase oneOrMore_greedy(const myRegexBase& arg);
    static myRegexBase oneOrMore_lazy(const myRegexBase& arg);
    static myRegexBase zeroOrOne_greedy(const myRegexBase& arg);
    static myRegexBase zeroOrOne_lazy(const myRegexBase& arg);
    static myRegexBase capture(const ::std::string& captName, const myRegexBase& arg);
    ::std::string getNamedCapture(const ::std::string& name, const ::std::smatch& m) const;
    ::std::string getExpr() const;
    bool match(const ::std::string& text, ::std::map<::std::string, myRegexBase::range>& captures);
    void allMatches(const ::std::string& text, ::std::vector<myRegexBase::range>& nonMatch, ::std::vector<::std::map<::std::string, myRegexBase::range>>& captures);
    static std::string namedCaptAsString(const std::string& name, std::map<std::string, myRegexBase::range> capt);
    static myRegexBase::range namedCaptAsRange(const std::string& name, std::map<std::string, myRegexBase::range> capt);
    static myRegexBase makeGrp(const myRegexBase& arg);
    myRegexBase makeGrp() const;
    static std::string test;

   protected:
    myRegexBase(const ::std::string& expr, bool isGroup);
    myRegexBase changeExpr(const ::std::string& newExpr, bool isGroup) const;
    std::map<std::string, myRegexBase::range> smatch2named(const std::smatch& m, const std::string::const_iterator start);
    MHPP("end myRegexBase")
   public:
    myRegexBase operator+(const myRegexBase& arg) const;
    myRegexBase operator|(const myRegexBase& arg) const;
    operator ::std::regex();

   protected:
    // expression in human-readable regex format
    ::std::string expr;
    // whether or not expr needs to be enclosed in group before a quantifier e.g. * is applied
    bool isGroup;
    // named captures in order of appearance
    ::std::vector<::std::string> captureNames;
};