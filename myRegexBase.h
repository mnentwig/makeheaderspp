#pragma once
#include <map>
#include <regex>
#include <string>
#include <tuple>
#include <vector>

#define MHPP(arg)  // arg is for makeheaderspp.exe, to be ignored by compiler
class myRegexBase {
   public:
    class range {
       public:
        range(::std::string::const_iterator istart, ::std::string::const_iterator ibegin, ::std::string::const_iterator iend) : istart(istart), ibegin(ibegin), iend(iend) {}
        // start of string that contains the range (e.g. to report line / character count in error messages)
        ::std::string::const_iterator start() const { return istart; }
        // start of range in a string beginning at start()
        ::std::string::const_iterator begin() const { return ibegin; }
        // end of range in a string beginning at start()
        ::std::string::const_iterator end() const { return iend; }
        ::std::string str() const{
            return ::std::string(ibegin, iend);
        }
       protected:
        ::std::string::const_iterator istart;
        ::std::string::const_iterator ibegin;
        ::std::string::const_iterator iend;
    };

    typedef ::std::pair<::std::string::const_iterator, ::std::string::const_iterator> range_t;
    MHPP("begin myRegexBase") // === autogenerated code. Do not edit ===
    public:
    	static myRegexBase  txt(const ::std::string& text);
    	static myRegexBase  rx(const ::std::string& re, bool isGroup);
    	static myRegexBase  zeroOrMore_greedy(const myRegexBase& arg);
    	static myRegexBase  zeroOrMore_lazy(const myRegexBase& arg);
    	static myRegexBase  oneOrMore_greedy(const myRegexBase& arg);
    	static myRegexBase  oneOrMore_lazy(const myRegexBase& arg);
    	static myRegexBase  zeroOrOne_greedy(const myRegexBase& arg);
    	static myRegexBase  zeroOrOne_lazy(const myRegexBase& arg);
    	static myRegexBase  capture(const ::std::string& captName, const myRegexBase& arg);
    	::std::string  getNamedCapture(const ::std::string& name, const ::std::smatch& m) const;
    	myRegexBase  operator+(const myRegexBase& arg) const;
    	myRegexBase  operator|(const myRegexBase& arg) const;
    	::std::string  getExpr() const;
    	bool  match(const ::std::string& text, ::std::map<::std::string, myRegexBase::range>& captures);
    	void  allMatches(const ::std::string& text, ::std::vector<myRegexBase::range>& nonMatch, ::std::vector<::std::map<::std::string, myRegexBase::range>>& captures);
    	static std::string  namedCaptAsString(const std::string& name, std::map<std::string, myRegexBase::range> capt);
    protected:
    	myRegexBase(const ::std::string& expr, bool isGroup);
    	myRegexBase  makeGrp() const;
    	static myRegexBase  makeGrp(const myRegexBase& arg);
    	myRegexBase  changeExpr(const ::std::string& newExpr, bool isGroup) const;
    	std::map<std::string, myRegexBase::range>  smatch2named(const std::smatch& m, const std::string::const_iterator start);
    MHPP("end myRegexBase")    
   public:
    operator ::std::regex();
   protected:
    // expression in human-readable regex format
    ::std::string expr;
    // whether or not expr needs to be enclosed in group before a quantifier e.g. * is applied
    bool isGroup;
    // named captures in order of appearance
    ::std::vector<::std::string> captureNames;
};