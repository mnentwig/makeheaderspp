#include "codegen.h"

using std::vector, std::string, std::runtime_error, std::map, std::cout, std::endl;
MHPP("public")
codeGen::codeGen(bool annotate) : annotate(annotate) {}

MHPP("public")
void codeGen::pass1(const std::string& fname, bool clean) {
    // === read file contents ===
    string all = readFile(fname);
    auto r = filebodyByFilename.insert({fname, all});
    if (!r.second) throw runtime_error("duplicate filename: '" + fname + "'");

    if (!clean) {
        // === break into nonmatch|match|nonmatch|...|nonmatch stream ===
        myAppRegex rx = myAppRegex::comment().makeGrp() | myAppRegex::MHPP_classfun().makeGrp() | myAppRegex::MHPP_classvar().makeGrp();
        std::vector<myAppRegex::range> nonCapt;
        std::vector<std::map<string, myAppRegex::range>> capt;
        rx.allMatches(all, nonCapt, capt);
        for (const auto& a : capt)
            MHPP_classitem(a, fname);
    }
}

MHPP("public")
void codeGen::pass2(const std::string& fname, bool clean) {
    // === retrieve original file contents ===
    auto it = filebodyByFilename.find(fname);
    assert(it != filebodyByFilename.end());
    string all = it->second;
    // === break into nonmatch|match|nonmatch|...|nonmatch stream ===
    myAppRegex rx = myAppRegex::MHPP_begin();
    std::vector<myAppRegex::range> nonCapt;
    std::vector<std::map<string, myAppRegex::range>> capt;
    rx.allMatches(all, nonCapt, capt);

    // === replace old file content between MHPP ("begin classname")...MHPP ("end classname") with respective classname's declarations ===
    const size_t nCapt = capt.size();
    if (nCapt == 0)
        return;
    assert(nonCapt.size() == nCapt + 1);  // implies > 0
    string res;
    for (size_t ixMatch = 0; ixMatch < nCapt; ++ixMatch) {
        res += nonCapt[ixMatch].str();
        res += MHPP_begin(capt[ixMatch], clean);
    }
    res += nonCapt[nCapt].str();

    // === replace in-memory file contents (but don't write yet) ===
    auto r2 = filebodyByFilename.find(fname);
    assert(r2 != filebodyByFilename.end());
    if (r2->second != res) {
        auto r = filesNeedRewrite.insert(fname);
        assert(/*insertion may not fail*/ r.second);
    }
    r2->second = res;
}

MHPP("public")
void codeGen::pass3(const std::string& fname) {
    if (filesNeedRewrite.find(fname) == filesNeedRewrite.end())
        return;
    auto it = filebodyByFilename.find(fname);
    assert(it != filebodyByFilename.end());
    string all = it->second;
#if true
    std::ofstream(fname, std::ios::binary) << all;
#else
    cout << fname << endl
         << all;
#endif
}

MHPP("public")
// called on declaration regex capture declaration
void codeGen::MHPP_classitem(const std::map<std::string, myAppRegex::range> capt, const std::string& fnameForErrMsg) {
    const string leadingComment = myAppRegex::namedCaptAsString("leadingComment", capt);
    bool isComment = leadingComment.size() > 0;
    if (isComment) {
        return;
    }
#if false
    cout << "=== non-comment classitem ===" << endl;
    for (auto x : capt) cout << x.first << "\t>>>" << x.second.str() << "<<<" << endl;
#endif

    const string fun_keyword = myAppRegex::namedCaptAsString("fun_MHPP_keyword", capt);
    const string var_keyword = myAppRegex::namedCaptAsString("var_MHPP_keyword", capt);
    bool isFun = fun_keyword.size() > 0;
    bool isVar = var_keyword.size() > 0;

    if (isFun && !isVar)
        MHPP_classfun(capt, fnameForErrMsg);
    else if (!isFun && isVar)
        MHPP_classvar(capt, fnameForErrMsg);
    else
        throw runtime_error("?? neither var nor fun (or both) ??");
}

MHPP("public")
std::string codeGen::MHPP_begin(const std::map<std::string, myAppRegex::range>& capt, bool clean) {
    auto it = capt.find("indent");
    assert(it != capt.end());
    string indent = it->second.str();

    it = capt.find("classname1");
    assert(it != capt.end());
    string classname1 = it->second.str();

    it = capt.find("classname2");
    assert(it != capt.end());
    string classname2 = it->second.str();

    if (classname1 != classname2) throw runtime_error("MHPP(\"begin " + classname1 + "\") terminated by MHPP(\"end " + classname2 + ")\"");

    string indentp1 = indent + "\t";

    string res;
    res += indent + "MHPP(\"begin " + classname1 + "\") // === autogenerated code. Do not edit ===\n";
    if (!clean) {
        auto itc = classesByName.find(classname1);
        if (itc == classesByName.end()) throw runtime_error("no data for MHPP(\"begin " + classname1 + "\")");

        // === sanity check that each class has only one AHBEGIN(classname)...AHEND section ===
        auto r2 = classDone.find(classname1);
        assert(r2 != classDone.end());
        if (r2->second) throw runtime_error("duplicate MHPP(\"begin...end " + classname1 + "\")");
        r2->second = true;

        const oneClass& c = itc->second;
        const string pubTxt = c.getPublicText(indentp1);
        const string protTxt = c.getProtectedText(indentp1);
        const string privTxt = c.getPrivateText(indentp1);
        if (pubTxt.size() > 0)
            res += indent + "public:\n" + pubTxt;
        if (protTxt.size() > 0)
            res += indent + "protected:\n" + protTxt;
        if (privTxt.size() > 0)
            res += indent + "private:\n" + privTxt;
    }
    res += indent + "MHPP(\"end " + classname1 + "\")";  // no newline (pattern ends before it)
    return res;
}

MHPP("public")
void codeGen::checkAllClassesDone() {
    for (auto it : classDone)
        if (!it.second)
            throw runtime_error("no MHPP(\"begin " + it.first + "\") ... MHPP(\"end " + it.first + "\") anywhere in files");
}

MHPP("protected")
oneClass& codeGen::getClass(const std::string& classname) {
    auto itc = classesByName.find(classname);
    if (itc == classesByName.end()) {
        // === create new oneClass for classnames ===
        auto r = classesByName.insert({classname, oneClass()});
        itc = r.first;
        assert(r.second);
        // === flag as class that is waiting to be collected by an MHPP ("begin classname")... MHPP("end classname") section ===
        auto r2 = classDone.insert({classname, false});
        assert(r2.second);
    }
    return itc->second;
}

MHPP("protected static")
std::string codeGen::trimNewline(std::string& text) {
    while (true) {
        if (text.size() == 0) break;
        char lastChar = text[text.size() - 1];
        if ((lastChar != '\n') && (lastChar != '\r')) break;
        text = text.substr(0, text.size() - 1);
    }
    return text;
}

MHPP("protected")
// called on declaration regex capture that is a function
void codeGen::MHPP_classfun(const std::map<std::string, myAppRegex::range> capt, const std::string& fnameForAnnot) {
    const myAppRegex::range all = myAppRegex::namedCaptAsRange("all", capt);
    const string keyword = myAppRegex::namedCaptAsString("fun_MHPP_keyword", capt);
    string comment = myAppRegex::namedCaptAsString("fun_comment", capt);
    const string returntype = myAppRegex::namedCaptAsString("fun_returntype", capt);
    const string classmethodname = myAppRegex::namedCaptAsString("fun_classmethodname", capt);
    const string arglist = myAppRegex::namedCaptAsString("fun_arglist", capt);
    const string postArg = myAppRegex::namedCaptAsString("fun_postArg", capt);
    assert(keyword.size() > 0);

    // parse classname::methodname
    myAppRegex rcm = myAppRegex::classMethodname();
    map<string, myAppRegex::range> cm;
    if (!rcm.match(classmethodname, cm)) {
        for (auto x : capt) cout << x.first << "\t>>>" << x.second.str() << "<<<" << endl;
        throw runtime_error("'" + classmethodname + "' is not of the expected format classname::(classname...)::methodname");
    }

    const string classname = myAppRegex::namedCaptAsString("classname", cm);
    const string methodname = myAppRegex::namedCaptAsString("methodname", cm);

    // build output line
    vector<string> destText;
    if (annotate)
        destText.push_back("/* " + fnameForAnnot + " " + all.getLcAnnotString() + " */");

    comment = trimNewline(comment);  // newline is required terminator for multiple comments. Remove last newline only here.
    if (comment.size() > 0)
        destText.push_back(comment);
    string line;
    bool isVirtual = keyword.find("virtual") != string::npos;
    bool isStatic = keyword.find("static") != string::npos;
    if (isVirtual && isStatic) throw runtime_error(all.getLcAnnotString() + " C++ doesn't allow virtual and static at the same time");
    if (isVirtual)
        line += "virtual ";
    if (isStatic)
        line += "static ";

    if (returntype.size() > 0)
        line += returntype + " ";
    line += methodname;
    line += arglist;
    if (postArg.find("const") != string::npos)
        line += " const";
    if (postArg.find("noexcept") != string::npos)
        line += " noexcept";

    line += ";";
    destText.push_back(line);
    oneClass& c = getClass(classname);
    c.addTextByKeyword(keyword, destText, /*for error message*/ classmethodname);

    // search for altclass=xyz
    std::vector<myAppRegex::range> altclassNonCapt;
    std::vector<std::map<string, myAppRegex::range>> altclassCapt;

    myAppRegex rAltCapt = myAppRegex::rx("altclass=") + myAppRegex::capture("altclass", myAppRegex::rx("[a-zA-Z0-9_:]+"));
    rAltCapt.allMatches(keyword, altclassNonCapt, altclassCapt);
    for (auto altclassMatch : altclassCapt) {
        if (isStatic) throw runtime_error(all.getLcAnnotString() + " An altclass-tagged method cannot be static");
        if (!isVirtual) throw runtime_error(all.getLcAnnotString() + " An altclass-tagged method needs to be virtual");
        const string altClass = myAppRegex::namedCaptAsString("altclass", altclassMatch);
        oneClass& cAlt = getClass(altClass);
        cAlt.addTextByKeyword("public", destText, /*for error message*/ classmethodname);
    }
}

MHPP("protected")
// called on declaration regex capture that is a static variable
void codeGen::MHPP_classvar(const std::map<std::string, myAppRegex::range> capt, const std::string& fnameForAnnot) {
    const myAppRegex::range all = myAppRegex::namedCaptAsRange("all", capt);
    const string keyword = myAppRegex::namedCaptAsString("var_MHPP_keyword", capt);
    string comment = myAppRegex::namedCaptAsString("var_comment", capt);
    const string returntype = myAppRegex::namedCaptAsString("var_returntype", capt);
    const string classvarname = myAppRegex::namedCaptAsString("var_classvarname", capt);
    assert(keyword.size() > 0);

    // parse classname::varname
    myAppRegex rcm = myAppRegex::classMethodname();  // reusing regex
    map<string, myAppRegex::range> cm;
    if (!rcm.match(classvarname, cm)) {
        for (auto x : capt) cout << x.first << "\t>>>" << x.second.str() << "<<<" << endl;
        throw runtime_error("'" + classvarname + "' is not of the expected format classname::(classname...)::varname");
    }

    const string classname = myAppRegex::namedCaptAsString("classname", cm);
    const string varname = myAppRegex::namedCaptAsString("methodname", cm);

    // build output line
    vector<string> destText;
    if (annotate)
        destText.push_back("/* " + fnameForAnnot + " " + all.getLcAnnotString() + " */");
    comment = trimNewline(comment);  // newline is required terminator for multiple comments. Remove last newline only here.
    if (comment.size() > 0)
        destText.push_back(comment);

    if (keyword.find("static") == string::npos)
        throw runtime_error("var " + varname + " must be static");
    string line;
    line += "static ";

    line += returntype;  // includes separating whitespace
    line += varname;
    line += ";";
    destText.push_back(line);

    oneClass& c = getClass(classname);
    c.addTextByKeyword(keyword, destText, classvarname);
}

MHPP("protected static")
std::string codeGen::readFile(const std::string& fname) {
    std::ostringstream oss;
    auto s = std::ifstream(fname, std::ios::binary);
    if (!s) throw runtime_error("failed to read '" + fname + "'");
    oss << std::ifstream(fname, std::ios::binary).rdbuf();
    return oss.str();
}
