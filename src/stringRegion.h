#pragma once
#include <regex>
#include <string>
#include <tuple>
#include <vector>

using std::string, std::pair, std::vector;
#ifndef MHPP
#define MHPP(arg)  // see https://github.com/mnentwig/makeheaderspp
#endif

// region of a string e.g. from regex match. Can be transfered to other string of same size e.g. for blanking comments before regex processing.
// note: caller must guarantee lifetime of referenced string
class stringRegion {
    MHPP("begin stringRegion") // === autogenerated code. Do not edit ===
    public:
    	// construct empty
    	stringRegion();
    	// construct spanning whole s
    	stringRegion(std::reference_wrapper<const string> s);
    	// construct spanning begin..end in s
    	stringRegion(std::reference_wrapper<const string> s, string::const_iterator begin, string::const_iterator end);
    	// construct spanning offsetBegin..offsetEnd in s
    	stringRegion(std::reference_wrapper<const string> s, size_t offsetBegin, size_t offsetEnd);
    	// construct spanning offsetBegin..offsetEnd in s
    	stringRegion(const std::shared_ptr<const string> s, size_t offsetBegin, size_t offsetEnd);
    	// construct offsetBegin..offsetEnd in sBegin..sEnd
    	stringRegion(const string::const_iterator sBegin, const string::const_iterator sEnd, size_t offsetBegin, size_t offsetEnd);
    	// construct region of regex submatch in s
    	stringRegion(std::reference_wrapper<const string> s, const std::ssub_match& subMatch);
    	// construct stringRegion for relative position from src on newS (which must have same size as src)
    	stringRegion(const stringRegion& src, std::reference_wrapper<const string> newS);
    	// replace underlying string with newS (which must hve same size)
    	void rebase(std::reference_wrapper<const string> newS);
    	// returns length
    	size_t size() const;
    	// creates new string with content of referenced region
    	string str() const;
    	// std::regex_match on content. Returns matches (matches.size()==0 if fail, otherwise full match plus captures)
    	vector<stringRegion> regex_match(std::regex r) const;
    	// regex_search on string region. Returns prefix, matches, postfix (matches.size()==0 if fail, otherwise full match plus captures)
    	std::tuple<stringRegion, vector<stringRegion>, stringRegion> regex_search(const std::regex& r) const;
    	// splits input text into sequence of non-matches and matches. Returns {nonMatch, match} with nonMatch.size() == match.size()+1
    	std::tuple<vector<stringRegion>, vector<vector<stringRegion>>> regexMatchNonMatch(const std::regex& r) const;
    	// remaps to new string (or non-const same string) and returns {begin, end} iterators. Note: Non-const variant, use for modifying
    	std::tuple<string::iterator, string::iterator> beginEnd(string& s) const;
    	// returns line-/character position of substring in source
    	void regionInSource(bool base1, /*out*/ size_t& lineBegin, size_t& charBegin, size_t& lineEnd, size_t& charEnd) const;
    private:
    	// construct region of regex submatch in sBegin..sEnd
    	stringRegion(const string::const_iterator sBegin, const string::const_iterator sEnd, const std::ssub_match& subMatch);
    MHPP("end stringRegion")
   private:
    // referenced string start
    string::const_iterator sBegin;
    // referenced string start
    string::const_iterator sEnd;
    // this region starts at offset into referenced string
    size_t offsetBegin;
    // this region ends at offset into referenced string
    size_t offsetEnd;
};