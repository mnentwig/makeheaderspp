#pragma once
#include <regex>
#include <string>
#include <tuple>
#include <vector>

using std::string, std::pair, std::vector;
#ifndef MHPP
#define MHPP(arg)  // see https://github.com/mnentwig/makeheaderspp
#endif

// region of a string e.g. from regex match. Can be transfered to other string of same size e.g. for blanking comments before regex processing.
// note: caller must guarantee lifetime of referenced string
class stringRegion {
    MHPP("begin stringRegion") // === autogenerated code. Do not edit ===
    public:
    	// empty region
    	stringRegion();
    	// region spanning whole s
    	stringRegion(const string& s);
    	// region begin..end in s
    	stringRegion(const string& s, string::const_iterator begin, string::const_iterator end);
    	// region of regex submatch in s
    	stringRegion(const string& s, const std::ssub_match& subMatch);
    	// returns length
    	size_t size() const;
    	// creates region with same relative position in new string of same size
    	stringRegion(const stringRegion& src, const string& newS);
    	// creates new string with content of referenced region
    	string str() const;
    	// std::regex_match on content. Returns matches (matches.size()==0 if fail, otherwise full match plus captures)
    	vector<stringRegion> regex_match(std::regex r);
    	// regex_search on string region. Returns prefix, matches, postfix (matches.size()==0 if fail, otherwise full match plus captures)
    	std::tuple<stringRegion, vector<stringRegion>, stringRegion> regex_search(const std::regex& r);
    	std::tuple<vector<stringRegion>, vector<vector<stringRegion>>> regexMatchNonMatch(const std::regex& r);
    private:
    	// region of regex submatch in s
    	stringRegion(const string::const_iterator sBegin, const string::const_iterator sEnd, const std::ssub_match& subMatch);
    MHPP("end stringRegion")
   private:
    string::const_iterator sBegin;
    string::const_iterator sEnd;
    size_t offsetBegin;
    size_t offsetEnd;
};