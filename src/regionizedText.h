#pragma once
#include <memory>
#include "regionized.h"
// "regionized" with ownership of input text copy
using std::string, std::vector, std::pair, std::shared_ptr;  // project convention
class regionizedText {
   public:
    typedef std::string::const_iterator csit_t;
    typedef regionized::rType_e rType_e;
    MHPP("begin regionizedText") // === autogenerated code. Do not edit ===
    public:
    	regionizedText(const std::string& text);
    	vector<regionized::region> getRegions() const;
    	regionized::region getRegion(size_t ixRegion) const;
    	csit_t begin() const;
    	// end() iterator into owned text
    	csit_t end() const;
    	// returns complete owned text
    	string str() const;
    	// maps region from internal text to "data" and fills with char.
    	void mask(string& data, const regionized::region& reg, char maskChar) const;
    	// maps region from internal text to "data" and fills with char.
    	void mask(string& data, const regionized::region& reg, char maskChar, char startChar, char endChar) const;
    	// maps regions filtered by rType from internal text to "data" and fills with char
    	void mask(string& data, const vector<regionized::region>& regions, regionized::rType_e rType, char maskChar) const;
    	// maps regions filtered by rType from internal text to "data" and fills with char
    	void mask(string& data, const vector<regionized::region>& regions, regionized::rType_e rType, char maskChar, char startChar, char endChar) const;
    	// returns all regions fully contained in iBegin..iEnd, filtered by rType (rType_e::INVALID selects all)
    	std::vector<regionized::region> getRegions(csit_t iBegin, csit_t iEnd, rType_e rType) const;
    	// given an iterator it from sOrig, return an iterator to the same position in (same-sized) sDest
    	static csit_t remapIterator(const std::string& sSrc, const std::string& sDest, const csit_t it);
    	// given an iterator it from external string sExt, return an iterator to the same position in (same-sized) object text
    	csit_t remapExtIteratorToInt(const std::string& sExt, const csit_t it) const;
    	// given iterators it1, it2 from external string sExt, return iterators to the same position in object text
    	std::pair<csit_t, csit_t> remapExtIteratorsToInt(const std::string& sExt, const pair<csit_t, csit_t> it) const;
    	// given iterators it1, it2 from external string sExt, refer to the same position in object text and return as string
    	std::string remapExtIteratorsToIntStr(const std::string& sExt, const pair<csit_t, csit_t> it) const;
    	// given an iterator it from object text, return an iterator to the same position in an external string sExt
    	csit_t remapIntIteratorToExt(const std::string& sExt, const csit_t it) const;
    	// returns line-/character position of substring in source
    	void regionInSource(const regionized::region& r, bool base1, /*out*/ size_t& lineBegin, size_t& charBegin, size_t& lineEnd, size_t& charEnd) const;
    	// returns line-/character position of substring in source
    	void regionInSource(csit_t iBegin, csit_t iEnd, bool base1, /*out*/ size_t& lineBegin, size_t& charBegin, size_t& lineEnd, size_t& charEnd) const;
    	static void testcases();
    private:
    	void mask(string& data, csit_t maskBegin, csit_t maskEnd, char maskChar) const;
    	void mask(string& data, csit_t maskBegin, csit_t maskEnd, char maskChar, char startChar, char endChar) const;
    MHPP("end regionizedText")
   private:
    // owned copy of input text
    const shared_ptr<const string> text;  // may never change (would invalidate region iterators)
    regionized regs;
};
