#pragma once
#ifndef MHPP
#define MHPP(arg)
#endif
#include <string>
#include <vector>
typedef std::string::const_iterator csit_t;  // shouldn't do this, for the sake of brevity
class regionizedText;

// Parses C(++) code recursively into list of bracketed-/quoted-/comment regions
class regionized {
   public:
    class region;
    typedef enum { INVALID,
                   TOPLEVEL,    // input expression
                   BRK_ANG,     // <>
                   BRK_RND,     // ()
                   BRK_SQU,     // []
                   BRK_CRL,     // {}
                   REM_CPP,     // /* this comment */
                   REM_C,       // // this comment
                   SQUOTE,      // 'x'
                   DQUOTE,      // "double quoted string" and qualified / raw variants
                   DQUOTE_BODY  // content of DQUOTE without brackets and qualifiers
    } rType_e;
    class region {
        friend regionizedText;            // iterator access
        MHPP("begin regionized::region")  // === autogenerated code. Do not edit ===
       public:
        region(csit_t begin, csit_t end, size_t level, regionized::rType_e rType);
        std::string str() const;
        size_t getLevel() const;
        regionized::rType_e getRType() const;
        bool startsAt(csit_t it) const;
        bool contains(const regionized::region& arg) const;
        MHPP("end regionized::region")
       private:
        // start iterator into externally owned text
        const csit_t begin;
        // end iterator into externally owned text
        const csit_t end;
        // recursion depth (debug / testcases)
        const size_t level;
        // content type e.g. which sort of brackets
        rType_e rType;
    };

    MHPP("begin regionized")  // === autogenerated code. Do not edit ===
   public:
    regionized(const csit_t begin, const csit_t end);
    // returns all regions (overlapping, in order of parsing, insertion at end of region)
    std::vector<regionized::region> getRegions() const;

   private:
    bool tokenFoundAtIt(const csit_t begin, const csit_t end, const std::string token);
    std::string getRawStringTerminatorOrDoubleQuote(const csit_t start, const csit_t end);
    csit_t cursor(csit_t begin, csit_t beginSearch, csit_t end, size_t level, std::vector<region>& result, const std::string tExit, rType_e rType);
    MHPP("end regionized");

   private:
    std::vector<region> regions;
};
