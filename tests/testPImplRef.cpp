// testcase source for MHPP pImpl generator (one file for combined .h and .cpp content)
// hint: run makeheaderspp.exe src/testPImpl.cpp -clean to remove the autogenerated code for clarity
// then run makeheaderspp.exe src/testPImpl.cpp to regenerate it
#include <cassert>   // using assert in main()
#include <iostream>  // print hello
#include <memory>    // std::shared_ptr for pImpl wrapper
#include <vector>    // using vector for demo
#define MHPP(arg)

// =====================================================================
// === mySuperComplexQueue aka SCQ
// =====================================================================
// a hypothetically large and complex class with interfaces for various
// external parties ("source", "sink") that should be hidden from each other
// e.g. a "source" API user should not see "sink" features in an IDE autocomplete list
// and vice versa
// this declaration goes to an "internal" .h file not referenced from any API .h file.
class mySuperComplexQueue {
    MHPP("begin mySuperComplexQueue") // === autogenerated code. Do not edit ===
    public:
    	mySuperComplexQueue(int x, int y, int z);
    	void push(int x);
    	int pop();
    	size_t size() const noexcept;
    MHPP("end mySuperComplexQueue")
   private:
    std::vector<int> body;
};

// implementation e.g. scq.so (/.dll) which hypothetically takes an eternity to build...
MHPP("public")
mySuperComplexQueue::mySuperComplexQueue(int x, int y, int z) : body({x, y}) { body.push_back(z); }

MHPP("public pImpl=myScqInputApi")
void mySuperComplexQueue::push(int x) { body.push_back(x); }

MHPP("public pImpl=myScqOutputApi")
int mySuperComplexQueue::pop() {
    int tmp = body.back();
    body.pop_back();
    return tmp;
}

MHPP("public pImpl=myScqInputApi pImpl=myScqOutputApi")
size_t mySuperComplexQueue::size() const noexcept { return body.size(); }

// =====================================================================
// === First pImpl API for "source" user ("may only feed into the queue")
// =====================================================================
// xyz_decl suffix denotes the declaration part for the pImpl=xyz target class.
class myScqInputApi {
    MHPP("begin myScqInputApi_decl") // === autogenerated code. Do not edit ===
    public:
    	myScqInputApi(std::shared_ptr<mySuperComplexQueue> pImpl);
    	void push (int x);
    	size_t size () const noexcept;
    protected:
    	std::shared_ptr<mySuperComplexQueue> pImpl;
    MHPP("end myScqInputApi_decl")
};

// =====================================================================
// === Second pImpl API for "sink" user ("may only take from the queue")
// =====================================================================
class myScqOutputApi {
    MHPP("begin myScqOutputApi_decl") // === autogenerated code. Do not edit ===
    public:
    	myScqOutputApi(std::shared_ptr<mySuperComplexQueue> pImpl);
    	int pop ();
    	size_t size () const noexcept;
    protected:
    	std::shared_ptr<mySuperComplexQueue> pImpl;
    MHPP("end myScqOutputApi_decl")
};

// =====================================================================
// === API implementation for "source"-side user
// =====================================================================
// this could go into scq.so(/.dll) or a wrapper
// xyz_impl suffix denotes the implementation part for the pImpl=xyz target class.
MHPP("begin myScqInputApi_impl") // === autogenerated code. Do not edit ===
	myScqInputApi::myScqInputApi(std::shared_ptr<mySuperComplexQueue> pImpl):pImpl(pImpl){};
	void myScqInputApi::push(int x){
		return pImpl->push(x);
	}
	size_t myScqInputApi::size() const noexcept{
		return pImpl->size();
	}
MHPP("end myScqInputApi_impl")

// =====================================================================
// === API implementation for "sink"-side user
// =====================================================================
// this could go into scq.so(/.dll) or a wrapper
MHPP("begin myScqOutputApi_impl") // === autogenerated code. Do not edit ===
	myScqOutputApi::myScqOutputApi(std::shared_ptr<mySuperComplexQueue> pImpl):pImpl(pImpl){};
	int myScqOutputApi::pop(){
		return pImpl->pop();
	}
	size_t myScqOutputApi::size() const noexcept{
		return pImpl->size();
	}
MHPP("end myScqOutputApi_impl")

int main(void) {
    // create an object as shared pointer to manage ownership
    std::shared_ptr<mySuperComplexQueue> scq = std::make_shared<mySuperComplexQueue>(10, 20, 30);

    // create an API wrapper for the "source" user
    myScqInputApi apiObjectForSource = myScqInputApi(scq);

    // create an API wrapper for the "sink" user
    myScqOutputApi apiObjectForSink = myScqOutputApi(scq);

    // use the objects...
    apiObjectForSource.push(40);
    apiObjectForSource.push(50);
    assert(apiObjectForSource.size() == 5);

    assert(apiObjectForSink.size() == 5);
    assert(apiObjectForSink.pop() == 50);
    assert(apiObjectForSink.pop() == 40);
    assert(apiObjectForSink.pop() == 30);
    assert(apiObjectForSink.pop() == 20);

    // API object behaves like the shared_ptr it is internally (e.g. may copy freely as reference to same object)
    myScqOutputApi sinkObjCopy = apiObjectForSink;
    assert(sinkObjCopy.pop() == 10);

    assert(apiObjectForSource.size() == 0);
    assert(apiObjectForSink.size() == 0);
    assert(scq->size() == 0);
    std::cout << "all OK!\n";

    return 0;
}